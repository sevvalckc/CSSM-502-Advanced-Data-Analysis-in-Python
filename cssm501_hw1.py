# -*- coding: utf-8 -*-
"""CSSM501_Hw1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U6_bpAM2eLfsgmtk35sIn0yo88uqQ-fh

# Problem 1 â€“ Number Guessing Game
This program generates a random number between 1 and 20.  
The user keeps guessing until the correct number is found.
It tells the user if their guess is too high or too low.
"""

import random

# Generate a random number between 1 and 20
correct_number = random.randint(1, 20)

print("Guess the number (between 1 and 20)!")

while True:
    guess = int(input("Enter your guess: "))

    if guess == correct_number:
        print("ðŸŽ‰ Correct! You guessed the number!")
        break
    elif guess < correct_number:
        print("Too low! Try again.")
    else:
        print("Too high! Try again.")

"""# Problem 2 â€“ Search Insert Position
Given a sorted array of distinct integers and a target value,  
return the index if the target is found.  
If not, return the index where it would be if it were inserted in order.
"""

def search_insert(nums, target):
    # nums: a sorted list of distinct integers
    # target: the integer to find or insert

    for i in range(len(nums)):
        # If the current element is greater than or equal to the target,
        # the target should be inserted at this position
        if nums[i] >= target:
            return i
    # If the target is greater than all elements, insert it at the end
    return len(nums)

# Example usage
nums = [1, 3, 5, 6]
print(search_insert(nums, 5))  # Output: 2
print(search_insert(nums, 2))  # Output: 1
print(search_insert(nums, 7))  # Output: 4
print(search_insert(nums, 0))  # Output: 0

"""# Problem 3 â€“ Add Binary
Given two binary strings `a` and `b`, return their sum as a binary string.

**Example:**  
Input: a = "11", b = "1"  
Output: "100"
"""

def add_binary(a, b):
    # Convert binary strings to integers
    num1 = int(a, 2)
    num2 = int(b, 2)

    # Compute the sum
    total = num1 + num2

    # Convert the sum back to a binary string
    return bin(total)[2:]

# Example usage
print(add_binary("11", "1"))      # Output: "100"
print(add_binary("1010", "1011")) # Output: "10101"

"""# Problem 4 â€“ Single Number
Given a non-empty array of integers `nums`, every element appears twice except for one.  
Find and return that single one.

"""

def single_number(nums):
    # Initialize a variable to hold the result
    unique = 0

    # XOR all numbers together
    for num in nums:
        unique ^= num  # XOR cancels out duplicates

    return unique

# Example usage
print(single_number([2, 2, 1]))       # Output: 1
print(single_number([4, 1, 2, 1, 2])) # Output: 4
print(single_number([1]))             # Output: 1

"""# Problem 5 â€“ DNA Repeated Sequences
A DNA sequence is composed of the characters `'A'`, `'C'`, `'G'`, and `'T'`.

Given a string `s` that represents a DNA molecule,  
return all the 10-letter-long sequences (substrings)  
that occur more than once in the DNA molecule.

**Example:**  
Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"  
Output: ["AAAAACCCCC", "CCCCCAAAAA"]

"""

def find_repeated_dna_sequences(s):
    seen = set()        # stores all 10-letter sequences we've seen
    repeated = set()    # stores sequences that appear more than once

    for i in range(len(s) - 9):  # -9 because we need substrings of length 10
        sequence = s[i:i+10]
        if sequence in seen:
            repeated.add(sequence)
        else:
            seen.add(sequence)

    return list(repeated)

# Example usage
s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
print(find_repeated_dna_sequences(s))
# Output: ['AAAAACCCCC', 'CCCCCAAAAA']